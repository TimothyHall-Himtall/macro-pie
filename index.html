<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Scan & Macro Pie</title>
<link rel="manifest" href="data:application/manifest+json,{&quot;name&quot;:&quot;Scan & Macro Pie&quot;,&quot;short_name&quot;:&quot;Macro Pie&quot;,&quot;display&quot;:&quot;standalone&quot;,&quot;icons&quot;:[]}" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<style>
  :root { font-family: -apple-system, system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
  body { margin: 0; background: #0f1115; color: #e8eaf0; }
  header { padding: 16px 20px; position: sticky; top: 0; backdrop-filter: blur(8px); background: rgba(15,17,21,0.8); border-bottom: 1px solid #2a2f3a; }
  h1 { font-size: 18px; margin: 0; }
  main { padding: 16px; display: grid; gap: 16px; }
  .card { background: #151922; border: 1px solid #2a2f3a; border-radius: 12px; padding: 14px; }
  .row { display: grid; gap: 12px; }

  .btn { appearance: none; border: 1px solid #3a4152; background: #1b2230; color: #e8eaf0; border-radius: 12px; padding: 12px 14px; font-weight: 700; }
  .btn:active { transform: scale(0.99); }
  .btn-lg { font-size: 18px; padding: 16px 18px; }
  /* High-visibility red Start button */
  .btn-primary { background: #c62828; border-color: #8e0000; color: #ffffff; box-shadow: 0 0 0 1px rgba(0,0,0,0.25) inset; }
  .btn-primary:active { transform: scale(0.98); }

  video { width: 100%; border-radius: 12px; background: #0b0d12; }
  label { font-size: 13px; color: #a8b0c2; }
  select, input[type="text"], input[type="range"] { width: 100%; padding: 10px 12px; border-radius: 10px; border: 1px solid #3a4152; background: #0f1320; color: #e8eaf0; }
  .grid2 { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
  .grid3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 12px; }
  .muted { color: #9aa3b6; font-size: 13px; }
  .small { font-size: 12px; color: #93a0b6; }
  .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; white-space: pre; }

  .ok { color:#6fe28c }
  .warn { color:#f2c56b }
  .err { color:#ff807a }

  /* Badges in a single vertical column */
  .badges { display:flex; flex-direction: column; gap:8px; align-items: flex-start; }
  .badge { display:inline-flex; align-items:center; gap:6px; padding:8px 12px; border-radius:999px; border:1px solid #3a4152; background:#101522; font-size:13px; max-width: 100%; }
  .badge.high   { border-color:#ff807a; color:#ff807a; }
  .badge.keto   { border-color:#6fe28c; color:#6fe28c; }
  .badge.protein{ border-color:#79d48a; color:#79d48a; }
  .badge.sugar  { border-color:#ffd54f; color:#ffd54f; }
  .badge.processed{ border-color:#90caf9; color:#90caf9; }
  .badge.risk-low    { border-color:#6fe28c; color:#6fe28c; }
  .badge.risk-med    { border-color:#ffd54f; color:#ffd54f; }
  .badge.risk-high   { border-color:#ffb74d; color:#ffb74d; }
  .badge.risk-very   { border-color:#ff807a; color:#ff807a; }

  .legend { display:grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap:8px; margin-top:6px; }
  .legend-item { display:flex; align-items:center; gap:8px; font-size:12px; color:#b8c2d8; }
  .swatch { width:12px; height:12px; border-radius:3px; border:1px solid rgba(255,255,255,0.15); }
  canvas { width: 100%; max-width: 560px; height: auto; }
</style>
</head>
<body>
<header><h1>Scan & Macro Pie</h1></header>
<main>

  <section class="card row">
    <div class="grid3">
      <!-- Bigger, red Start Scan button -->
      <button id="startBtn" class="btn btn-primary btn-lg">üì∑ Start Scan</button>
      <button id="stopBtn" class="btn" disabled>‚èπ Stop</button>
      <button id="torchBtn" class="btn" disabled>üî¶ Torch</button>
    </div>
    <video id="preview" playsinline></video>
    <div class="grid2">
      <div>
        <label>Zoom</label>
        <input id="zoomRange" type="range" min="1" max="1" step="0.1" value="1" disabled />
      </div>
      <div>
        <label class="small">Pinch on video to zoom</label>
        <div id="zoomLabel" class="small mono"></div>
      </div>
    </div>
    <div id="status" class="mono small"></div>

    <div class="grid2">
      <div>
        <label>Or enter a barcode (UPC/EAN)</label>
        <input id="barcodeInput" type="text" inputmode="numeric" placeholder="e.g., 036000291452" />
      </div>
      <div>
        <label>&nbsp;</label>
        <button id="lookupBtn" class="btn">üîé Look Up</button>
      </div>
    </div>
    <div class="small">Tips: Use the torch in dim light. Zoom until the barcode fills most of the frame. Hold steady 1‚Äì2s.</div>
  </section>

  <section class="card row">
    <div class="grid2">
      <div>
        <label>Nutrition basis</label>
        <select id="basis">
          <option value="serving">Per serving (if available)</option>
          <option value="100g">Per 100g</option>
        </select>
      </div>
      <div>
        <label>Serving size (auto if provided)</label>
        <input id="servingText" type="text" placeholder="e.g., 1 cup (240 ml)" />
      </div>
    </div>
    <div id="productMeta" class="muted"></div>
    <!-- Stacked badges -->
    <div class="badges" id="badgeRow"></div>
  </section>

  <section class="card row">
    <canvas id="chart"></canvas>
    <div id="macroText" class="mono small"></div>

    <!-- Legend (fixed colors) -->
    <div class="legend">
      <div class="legend-item"><span class="swatch" style="background:#a8d8ff"></span>Monounsaturated fat (M)</div>
      <div class="legend-item"><span class="swatch" style="background:#ffe082"></span>Sugar (natural) (Su)</div>
      <div class="legend-item"><span class="swatch" style="background:#7fc6ff"></span>Polyunsaturated fat (P)</div>
      <div class="legend-item"><span class="swatch" style="background:#ffca28"></span>Added sugar (A)</div>
      <div class="legend-item"><span class="swatch" style="background:#5fb0ff"></span>Other fat (F)</div>
      <div class="legend-item"><span class="swatch" style="background:#fff59d"></span>Other carbs (C)</div>
      <div class="legend-item"><span class="swatch" style="background:#3f8efc"></span>Saturated fat (S)</div>
      <div class="legend-item"><span class="swatch" style="background:#ffa726"></span>Fiber (Fi)</div>
      <div class="legend-item"><span class="swatch" style="background:#1f6fe6"></span>Trans fat (T)</div>
      <div class="legend-item"><span class="swatch" style="background:#79d48a"></span>Protein (Pr)</div>
    </div>

    <div class="small">Fats split into MUFA (M), PUFA (P), Saturated (S), Trans (T), and Other (F). Carbs split into Fiber (Fi), Sugar natural (Su), Added (A), and Other (C).</div>
  </section>

  <section class="card">
    <div class="small">
      Data: Open Food Facts. ‚ÄúOther carbs‚Äù = total carbs ‚àí fiber ‚àí total sugars (‚â•0). ‚ÄúSugar (natural)‚Äù = total sugars ‚àí added sugars (‚â•0). Net carbs ‚âà total carbs ‚àí fiber ‚àí sugar alcohols (polyols). Sodium ‚ÄúHigh‚Äù at ‚â•460 mg per selected basis. Badges and risk score are **heuristics for education**, not medical advice.
    </div>
  </section>

</main>

<!-- ZXing fallback -->
<script src="https://unpkg.com/@zxing/browser@latest"></script>
<!-- Chart.js -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
<!-- Chart.js datalabels for letters in slices -->
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0"></script>
<script>
/* ======= Elements ======= */
const video = document.getElementById('preview');
const startBtn = document.getElementById('startBtn');
const stopBtn = document.getElementById('stopBtn');
const torchBtn = document.getElementById('torchBtn');
const zoomRange = document.getElementById('zoomRange');
const zoomLabel = document.getElementById('zoomLabel');
const statusEl = document.getElementById('status');
const barcodeInput = document.getElementById('barcodeInput');
const lookupBtn = document.getElementById('lookupBtn');
const basisSel = document.getElementById('basis');
const servingText = document.getElementById('servingText');
const productMeta = document.getElementById('productMeta');
const badgeRow = document.getElementById('badgeRow');
const chartEl = document.getElementById('chart');
const macroText = document.getElementById('macroText');

/* ======= State ======= */
let mediaStream = null;
let track = null;
let zxReader = null;
let zxControls = null;
let detectLoopRunning = false;
let hasTorch = false, torchOn = false;
let chart = null;

/* ======= UI helpers ======= */
function setStatus(msg, cls='') {
  statusEl.textContent = msg;
  statusEl.className = 'mono small ' + cls;
}
function grams(val){ return typeof val === 'number' ? val : (val ? parseFloat(val) : 0); }
function toFixed1(n){ return (Math.round(n*10)/10).toFixed(1); }

/* ======= Barcode helpers ======= */
function normalizeBarcodes(raw) {
  const code = (raw || '').replace(/\D/g,'');
  if (!code) return [];
  const list = new Set([code]);
  if (code.length === 12) list.add('0'+code); // UPC-A -> EAN-13
  if (code.length === 13 && code.startsWith('0')) list.add(code.slice(1)); // EAN-13 -> UPC-A
  return Array.from(list);
}

/* ======= Nutrition extraction ======= */
function pickNutriments(n, per) {
  const f = (k) => grams(n[k]);
  const get = (servingKey, g100Key) => per==='serving' ? f(servingKey) : f(g100Key);

  // Totals
  const fat = get('fat_serving', 'fat_100g');
  const protein = get('proteins_serving', 'proteins_100g');
  const carbs = get('carbohydrates_serving', 'carbohydrates_100g');
  const fiber = get('fiber_serving', 'fiber_100g');
  const sugarsTotal = get('sugars_serving', 'sugars_100g');
  const addedSugars = get('added-sugars_serving', 'added-sugars_100g');
  const polyols = get('polyols_serving', 'polyols_100g'); // sugar alcohols if provided

  // Fat subtypes
  const sat = get('saturated-fat_serving', 'saturated-fat_100g');
  const trans = get('trans-fat_serving', 'trans-fat_100g') || get('transfat_serving','transfat_100g');
  const mufa = get('monounsaturated-fat_serving', 'monounsaturated-fat_100g');
  const pufa = get('polyunsaturated-fat_serving', 'polyunsaturated-fat_100g');

  // Derived
  const otherFat = Math.max(fat - (mufa + pufa + sat + trans), 0);
  const sugarNatural = Math.max(sugarsTotal - addedSugars, 0);
  const otherCarbs = Math.max(carbs - fiber - sugarsTotal, 0);

  return {
    fat, protein, carbs, fiber, sugarsTotal, addedSugars, sugarNatural, otherCarbs,
    mufa, pufa, sat, trans, otherFat, polyols
  };
}

function kcalFromMacros({fat, protein, fiber, sugarsTotal, otherCarbs}) {
  // Energy factors: fat 9, protein 4, carbs 4, fiber 2
  return Math.round(fat*9 + protein*4 + (sugarsTotal+otherCarbs)*4 + fiber*2);
}

/* ======= Badges: sodium, keto, high-protein, low-sugar, processed ======= */
function getSodiumMg(n, per) {
  const sodium = per==='serving' ? grams(n['sodium_serving']) : grams(n['sodium_100g']);
  const salt = per==='serving' ? grams(n['salt_serving']) : grams(n['salt_100g']);
  if (sodium) return sodium * 1000;
  if (salt) return salt * 0.393 * 1000;
  return 0;
}
function renderBadges({ sodiumMg, netCarbs, basisLabel, proteinG, sugarsG, novaGroup }) {
  const HIGH_SODIUM_MG = 460;
  const HIGH_PROTEIN_SERV = 20, HIGH_PROTEIN_100G = 10;
  const LOW_SUGAR_THR = 5;

  const items = [];
  items.push(`<span class="badge${sodiumMg>=HIGH_SODIUM_MG?' high':''}">üßÇ Sodium: ${Math.round(sodiumMg)} mg${sodiumMg>=HIGH_SODIUM_MG?' ‚Ä¢ High':''}</span>`);
  items.push(`<span class="badge${netCarbs<=5?' keto':''}">ü•ë Keto-Friendly: ${toFixed1(netCarbs)} g net ${basisLabel}</span>`);
  const isHighProtein = (basisLabel.includes('100 g') ? proteinG>=HIGH_PROTEIN_100G : proteinG>=HIGH_PROTEIN_SERV);
  items.push(`<span class="badge${isHighProtein?' protein':''}">ü•© High Protein: ${toFixed1(proteinG)} g ${basisLabel}</span>`);
  const isLowSugar = sugarsG <= LOW_SUGAR_THR;
  items.push(`<span class="badge${isLowSugar?' sugar':''}">üç¨ Low Sugar: ${toFixed1(sugarsG)} g ${basisLabel}</span>`);
  if (novaGroup) {
    const processed = Number(novaGroup) === 4;
    items.push(`<span class="badge${processed?' processed':''}">üè≠ ${processed ? 'Highly-Processed (NOVA 4)' : 'Processing: NOVA '+novaGroup}</span>`);
  }
  badgeRow.innerHTML = items.join('');
}

/* ======= Cancer-risk heuristic (0‚Äì10, educational only) ======= */
function computeCancerRiskHeuristic(product) {
  const n = product.nutriments || {};
  const g = (k) => grams(n[k]);
  const added100 = g('added-sugars_100g');
  const trans100 = g('trans-fat_100g') || g('transfat_100g');
  const sodium100_mg = (g('sodium_100g') ? g('sodium_100g')*1000 : (g('salt_100g') ? g('salt_100g')*0.393*1000 : 0));
  const fiber100 = g('fiber_100g');
  const nova = Number(product.nova_group || 0);

  let score = 0;
  if (nova === 4) score += 3; else if (nova === 3) score += 1;
  score += Math.min(2, Math.max(0, added100 / 5));
  if (trans100 && trans100 > 0) score += 2;
  if (sodium100_mg >= 1200) score += 2; else if (sodium100_mg >= 600) score += 1;
  if (fiber100 < 1) score += 2; else if (fiber100 < 3) score += 1;
  const ing = (product.ingredients_text || '').toLowerCase();
  if (/\bnitrite\b|\bnitrate\b|sodium nitrite|potassium nitrite|sodium nitrate|potassium nitrate/.test(ing)) score += 1;

  score = Math.max(0, Math.min(10, score));
  let band = 'low';
  if (score >= 7.5) band = 'very';
  else if (score >= 5) band = 'high';
  else if (score >= 2.5) band = 'med';
  return { score: Number(score.toFixed(1)), band };
}
function renderCancerRiskBadge(risk) {
  const cls = risk.band === 'very' ? 'risk-very' : risk.band === 'high' ? 'risk-high' : risk.band === 'med' ? 'risk-med' : 'risk-low';
  const html = `<span class="badge ${cls}">üéØ Cancer-Risk Heuristic: ${risk.score} / 10</span>`;
  badgeRow.innerHTML += (badgeRow.innerHTML ? '' : '') + html;
}

/* ======= Chart (fixed colors + bigger letters) ======= */
const COLORS = {
  mufa: '#a8d8ff', pufa: '#7fc6ff', otherFat: '#5fb0ff', sat: '#3f8efc', trans: '#1f6fe6',
  fiber: '#ffa726', sugarNatural: '#ffe082', added: '#ffca28', otherCarbs: '#fff59d',
  protein: '#79d48a'
};
const SLICE_KEYS = ['mufa','pufa','otherFat','sat','trans','fiber','sugarNatural','addedSugars','otherCarbs','protein'];
const SLICE_LABELS = [
  'Monounsaturated fat (g)','Polyunsaturated fat (g)','Other fat (g)','Saturated fat (g)','Trans fat (g)',
  'Fiber (g)','Sugar (natural) (g)','Added sugar (g)','Other carbs (g)','Protein (g)'
];
const SLICE_COLORS = [COLORS.mufa, COLORS.pufa, COLORS.otherFat, COLORS.sat, COLORS.trans, COLORS.fiber, COLORS.sugarNatural, COLORS.added, COLORS.otherCarbs, COLORS.protein];
const SLICE_LETTERS = ['M','P','F','S','T','Fi','Su','A','C','Pr'];

function isDark(hex){
  const c = hex.replace('#','');
  const r = parseInt(c.substr(0,2),16), g = parseInt(c.substr(2,2),16), b = parseInt(c.substr(4,2),16);
  const l = (0.299*r + 0.587*g + 0.114*b)/255;
  return l < 0.55;
}

function updateChart(label, parts) {
  const data = SLICE_KEYS.map(k => Math.max(0, parts[k] || 0));
  if (chart) chart.destroy();
  Chart.register(ChartDataLabels);

  chart = new Chart(chartEl, {
    type: 'doughnut',
    data: { labels: SLICE_LABELS, datasets: [{ data, backgroundColor: SLICE_COLORS }] },
    options: {
      responsive: true,
      cutout: '45%',
      plugins: {
        legend: { display: false },
        title: { display: true, text: label },
        datalabels: {
          formatter: (value, ctx) => (!value || value < 0.5) ? '' : SLICE_LETTERS[ctx.dataIndex],
          font: { weight: 800, size: 15 },           /* bigger letters */
          color: (ctx) => isDark(SLICE_COLORS[ctx.dataIndex]) ? '#ffffff' : '#0b0d12',
          textStrokeColor: '#000000',
          textStrokeWidth: 1,                         /* thicker outline for contrast */
          clamp: true,
          clip: false
        }
      }
    }
  });

  const kcal = kcalFromMacros(parts);
  macroText.textContent =
`Protein:      ${toFixed1(parts.protein)} g
FAT ‚Üí MUFA:   ${toFixed1(parts.mufa)} g ‚Ä¢ PUFA: ${toFixed1(parts.pufa)} g ‚Ä¢ Sat: ${toFixed1(parts.sat)} g ‚Ä¢ Trans: ${toFixed1(parts.trans)} g ‚Ä¢ Other: ${toFixed1(parts.otherFat)} g
CARBS ‚Üí Fiber:${toFixed1(parts.fiber)} g ‚Ä¢ Sugar (natural): ${toFixed1(parts.sugarNatural)} g ‚Ä¢ Added: ${toFixed1(parts.addedSugars)} g ‚Ä¢ Other: ${toFixed1(parts.otherCarbs)} g
-----------------------------------------
Est. calories: ${kcal} kcal`;
}

/* ======= Fetch & render ======= */
async function fetchOFF(code) {
  const url = `https://world.openfoodfacts.org/api/v2/product/${encodeURIComponent(code)}.json`;
  const res = await fetch(url, { cache: 'no-store' });
  if (!res.ok) throw new Error('Network error');
  const j = await res.json();
  if (!j || j.status !== 1 || !j.product) return null;
  return j.product;
}
async function lookupAny(rawCode) {
  const tries = normalizeBarcodes(rawCode);
  for (const c of tries) { const p = await fetchOFF(c); if (p) return p; }
  return null;
}
function setMeta(p, per) {
  const brand = p.brands || '';
  const name = p.product_name || p.generic_name || 'Unnamed product';
  const serving = p.serving_size || '';
  servingText.value = serving || servingText.value;
  productMeta.innerHTML = `
    <div><strong>${brand ? brand + ' ‚Äî ' : ''}${name}</strong></div>
    <div class="small">Barcode: ${p.code}</div>
    <div class="small">Nutrition basis: <code>${per === 'serving' ? 'per serving' : 'per 100g'}</code>${serving ? ` ‚Ä¢ Serving size: <code>${serving}</code>` : ''}</div>
  `;
}
async function doLookup(raw) {
  setStatus('Looking up product‚Ä¶', 'warn');
  productMeta.textContent = ''; badgeRow.innerHTML = '';
  const p = await lookupAny(raw);
  if (!p) { setStatus('No product found for that code on Open Food Facts.', 'err'); return; }
  const preferred = (basisSel.value === 'serving' && p.nutrition_data_per === 'serving')
    ? 'serving' : (basisSel.value === '100g' ? '100g' : (p.nutrition_data_per === '100g' ? '100g' : 'serving'));
  setMeta(p, preferred);

  const parts = pickNutriments(p.nutriments || {}, preferred);
  const sodiumMg = getSodiumMg(p.nutriments || {}, preferred);
  const netCarbs = Math.max(parts.carbs - parts.fiber - (parts.polyols || 0), 0);
  const basisLabel = preferred === 'serving' ? '(per serving)' : '(per 100 g)';

  renderBadges({ sodiumMg, netCarbs, basisLabel, proteinG: parts.protein, sugarsG: parts.sugarsTotal, novaGroup: p.nova_group });

  const risk = computeCancerRiskHeuristic(p);
  renderCancerRiskBadge(risk);

  const label = `${(p.brands||'').split(',')[0] ?? ''} ${(p.product_name||'')}`.trim() || 'Product';
  updateChart(label, parts);
  setStatus('Product found ‚úîÔ∏é', 'ok');
}

/* ======= Camera & scanning (iOS-friendly) ======= */
const BARCODE_FORMATS = ['ean_13','ean_8','upc_a','upc_e','code_128'];

async function startCamera() {
  if (mediaStream) return;
  setStatus('Requesting camera‚Ä¶', 'warn');
  try {
    mediaStream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: { ideal: 'environment' }, width: { ideal: 1920 }, height: { ideal: 1080 }, advanced: [{ focusMode: 'continuous' }] },
      audio: false
    });
    video.srcObject = mediaStream;
    await video.play();
    setStatus('Camera started. Scanning‚Ä¶', 'ok');

    track = mediaStream.getVideoTracks()[0];
    const caps = track.getCapabilities ? track.getCapabilities() : {};

    hasTorch = !!caps.torch;
    torchBtn.disabled = !hasTorch;
    torchBtn.textContent = hasTorch ? 'üî¶ Torch (Off)' : 'üî¶ Torch N/A';

    if (caps.zoom && typeof caps.zoom.min === 'number') {
      zoomRange.min = caps.zoom.min;
      zoomRange.max = caps.zoom.max;
      zoomRange.step = caps.zoom.step || 0.1;
      zoomRange.value = caps.zoom.min;
      zoomRange.disabled = false;
      zoomLabel.textContent = `Zoom: ${Number(zoomRange.value).toFixed(1)}√ó`;
    } else {
      zoomRange.disabled = true;
      zoomLabel.textContent = 'Zoom: N/A';
    }

    const usedNative = await loopBarcodeDetector();
    if (!usedNative) { setStatus('Using ZXing fallback‚Ä¶', 'warn'); await startZXing(); }
    else { setStatus('Using native scanner‚Ä¶', 'ok'); }
  } catch (e) {
    setStatus('Camera start failed. Ensure HTTPS and camera permission in Settings > Safari.', 'err');
    throw e;
  }
}

async function stopCamera() {
  if (detectLoopRunning) detectLoopRunning = false;
  if (zxControls) { zxControls.stop(); zxControls = null; }
  if (zxReader) { try { zxReader.reset(); } catch(e){} zxReader = null; }
  if (video) { try { video.pause(); } catch(e){} }
  if (track) { try { await setTorch(false); } catch(_) {} track = null; }
  if (mediaStream) { mediaStream.getTracks().forEach(t => t.stop()); mediaStream = null; }
  setStatus('Camera stopped.', 'warn');
}

async function setTorch(on) {
  if (!track || !hasTorch) return false;
  try {
    await track.applyConstraints({ advanced: [{ torch: !!on }] });
    torchOn = !!on;
    torchBtn.textContent = torchOn ? 'üî¶ Torch (On)' : 'üî¶ Torch (Off)';
    return true;
  } catch { setStatus('Torch not supported on this camera.', 'err'); return false; }
}
async function setZoom(val) {
  if (!track) return;
  try { await track.applyConstraints({ advanced: [{ zoom: Number(val) }] }); zoomLabel.textContent = `Zoom: ${Number(val).toFixed(1)}√ó`; }
  catch { /* ignore */ }
}

/* Native detector loop */
async function loopBarcodeDetector() {
  if (!('BarcodeDetector' in window)) return false;
  let detector; try { detector = new window.BarcodeDetector({ formats: BARCODE_FORMATS }); } catch { return false; }
  detectLoopRunning = true;
  const offscreen = document.createElement('canvas'); const ctx = offscreen.getContext('2d');
  const tick = async () => {
    if (!detectLoopRunning) return;
    try {
      const w = video.videoWidth, h = video.videoHeight;
      if (w && h) {
        offscreen.width = w; offscreen.height = h;
        ctx.drawImage(video, 0, 0, w, h);
        const barcodes = await detector.detect(offscreen);
        if (barcodes && barcodes.length) {
          const txt = (barcodes[0].rawValue || barcodes[0].data || '').toString();
          detectLoopRunning = false;
          await stopCamera();
          barcodeInput.value = txt;
          await doLookup(txt);
          return;
        }
      }
    } catch (e) { /* continue */ }
    requestAnimationFrame(tick);
  };
  requestAnimationFrame(tick);
  return true;
}

/* ZXing fallback */
async function startZXing() {
  try {
    zxReader = new ZXingBrowser.BrowserMultiFormatReader();
    zxControls = await zxReader.decodeFromVideoDevice(null, video, async (result, err, controls) => {
      if (result) {
        const txt = result.getText();
        await stopCamera();
        barcodeInput.value = txt;
        await doLookup(txt);
      }
    });
    return true;
  } catch (e) { setStatus('ZXing failed to start.', 'err'); return false; }
}

/* ======= Events ======= */
startBtn.addEventListener('click', async () => {
  startBtn.disabled = true; stopBtn.disabled = false;
  try { await startCamera(); } catch (_) { startBtn.disabled = false; stopBtn.disabled = true; }
});
stopBtn.addEventListener('click', async () => { await stopCamera(); startBtn.disabled = false; stopBtn.disabled = true; torchBtn.disabled = true; });
torchBtn.addEventListener('click', async () => { if (hasTorch) await setTorch(!torchOn); });
zoomRange.addEventListener('input', async (e) => { await setZoom(e.target.value); });

/* Pinch-to-zoom */
let baseScale = 1, pinchStart = null;
video.addEventListener('touchstart', (e) => {
  if (e.touches.length === 2 && !zoomRange.disabled) {
    pinchStart = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
    baseScale = Number(zoomRange.value);
  }
}, { passive: true });
video.addEventListener('touchmove', async (e) => {
  if (e.touches.length === 2 && pinchStart && !zoomRange.disabled) {
    const dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
    let next = baseScale * (dist / pinchStart);
    next = Math.max(zoomRange.min, Math.min(zoomRange.max, next));
    zoomRange.value = next;
    await setZoom(next);
  }
}, { passive: true });

lookupBtn.addEventListener('click', async () => { const code = (barcodeInput.value || '').trim(); if (!code) return; await doLookup(code); });
basisSel.addEventListener('change', async () => { const code = (barcodeInput.value || '').trim(); if (code) await doLookup(code); });
</script>
</body>
</html>
